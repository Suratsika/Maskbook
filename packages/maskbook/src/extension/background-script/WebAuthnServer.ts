import { createPublicKeyAuthenticator } from '@dimensiondev/mask-webauthn/backend'
import { parseInt } from 'lodash-es'
import { encodeArrayBuffer } from '@dimensiondev/kit'
import type { PersonaWithPrivateKey } from '../../database'
import { queryPersonasWithPrivateKey } from '../../database/Persona/Persona.db'
import { derive_AES_GCM_256_Key_From_ECDH_256k1_Keys } from '../../modules/CryptoAlgorithm/helper'

const parseID = (credentialID: ArrayBuffer) => `webauth-${encodeArrayBuffer(credentialID)}`

async function selectPersona(): Promise<PersonaWithPrivateKey> {
    // todo: show a popup to let user select one from personas
    const personas = await queryPersonasWithPrivateKey()
    return personas[0]
}

async function getResidentKeyPair(rpID: string) {
    const persona = await selectPersona()
    const secretKey = await derive_AES_GCM_256_Key_From_ECDH_256k1_Keys(persona.privateKey, persona.publicKey)
}
async function getKeyPairByKeyWrap(rpID: string, candidateCredentialIDs: ArrayBuffer[]) {}
async function createKeyPairByKeyWrap(rpID: string, excludeCredentials: ArrayBuffer[]) {}

export const { get, create } = createPublicKeyAuthenticator({
    async getSignCount(key: CryptoKey, rpID: string, credentialID: ArrayBuffer) {
        return parseInt(localStorage.getItem(parseID(credentialID)) || '0')
    },
    incrementSignCount(key: CryptoKey, rpID: string, credentialID?: ArrayBuffer | null) {
        const currentValue = localStorage.getItem(parseID(credentialID ?? new Uint8Array(0))) || '0'
        return Promise.resolve()
    },
    hasCredential(rpID: string, credentialID: ArrayBuffer) {
        // Step:
        // 1. If there is a residental key presistes with the same credentialID
        //      a. return true
        // 2. For each persona _p_,
        //      a. Try unwrap credentialID with _p_. If success, return true
        // 3. return false
        throw new Error()
    },
    async getResidentKeyPair(rpID: string) {
        // !!!!!!!! Please let @yisiliu review this algorithm before implementing it !!!!!!!!

        // 1. let _selectedPersona_ to be await selectPersona()
        // Note: selectPersona() should be a function that create a popup to let the user select,
        //       but you can implement it to choose the 1st persona found for now.
        // 2. let _keyID_ to be the determinstic hash/random ID with _selectedPersona_.privateKey and_rpID_ as the source of the entropy.
        // Note: if failed to connected to the key registry, fails the algorithm
        // 3. let _key_ to be await searchKeyOnGlobalRegistry(_keyID_)
        // Note: searchKeyOnGlobalRegistry() should be a function that searches the key on gun,
        //       but you can implement it to a local Map<string, JsonWebKey> for now.
        // 4. if _key_ is *undefined*,
        //      a. let _new_ to be a newly created secp256r1 (P-256) keypair with usage "sign" and "verify"
        //      b. let _jwk_ to be await crypto.subtle.exportKey("jwk", _new_.privateKey)
        //      !!!!!! This step use ECDH to derive a new AES key with THEMSELF !!!!!!
        //          Question(@yisiliu):
        //              1. Is this key determinstic(which means I can get the same key back in the future with only _selectedPersona_.publicKey and privateKey) ?
        //              2. Is this safe?
        //      c. let _self_secret_key_ to be derive_aes_from_ecdh(_selectedPersona_.privateKey, _selectedPersona.publicKey, aes = 'AES-GCM', length = 256)
        //      d. let _iv_ to be crypto.getRandomValues(new Uint8Array(16))
        //      // encrypt jwk of resident key of AES key that generated by ECDH with myself
        //      e. let _encrypted_ to be _iv_ + encrypt_aes(_self_secret_key_, _iv_, _jwk_)
        //      // we have to make sure this step success before we return the key.
        //      f. await publishKeyOnGlobalRegistry(_keyID_, _encrypted_)
        //      g. return _new_
        // 5. let _iv_ be first 16 uint8 of the _key.
        // 6. let _encrypted_ to be the rest part of the _key_.
        // Note: the generated key should be the same with step 4.b, otherwise it won't work.
        // 7. let _self_secret_key_ to be derive_aes_from_ecdh(_selectedPersona_.privateKey, _selectedPersona.publicKey, aes = 'AES-GCM', length = 256)
        // Note: if this step fails, we have nothing to do, but fails.
        // 8. let _jwk_ to be decrypt_aes(_self_secret_key_, _iv_, _encrypted_)
        // 9. let _keyPair_ to be importKey("jwk", _keyPair_) // ? can we get public key back ?
        // 10. return _keyPair_
        throw new Error()
    },
    getKeyPairByKeyWrap(rpID: string, candidateCredentialIDs: ArrayBuffer[]) {
        throw new Error()
    },
    createKeyPairByKeyWrap(rpID: string, excludeCredentialIDs: ArrayBuffer[]) {
        throw new Error()
    },
})
